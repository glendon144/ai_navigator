#!/usr/bin/env python3
#
# ai_navigator.py — Single-file build with embedded OPML rendering shim
#
# Pane layout:
#   [ BrowserPane | ResultsPane | OutlinePane | AssistantPane ]
#
# Notable features in this build:
# - Absolute archive_export.opml path anchored to this file's folder
# - Reveal button shows the OPML directory
# - Embedded "opml_extras_v3" shim for pretty, collapsible trees (no external import)
# - Expand/Collapse buttons
# - Error popups include the full path to the OPML
#
from __future__ import annotations

import sys, re, os, webbrowser, subprocess, sqlite3, xml.etree.ElementTree as ET
from pathlib import Path
from datetime import datetime
from urllib.parse import urlparse

from PySide6.QtCore import Qt, QSize, QTimer, QRect, QUrl, Signal
from PySide6.QtGui import QPixmap, QPainter, QPen, QBrush, QColor, QTransform, QPainterPath, QGuiApplication, QDesktopServices, QClipboard
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QDockWidget, QWidget, QVBoxLayout, QHBoxLayout,
    QLineEdit, QPushButton, QTextEdit, QListWidget, QListWidgetItem,
    QTreeWidget, QTreeWidgetItem, QSplitter, QLabel, QMessageBox, QSizePolicy, QMenuBar
)
from PySide6.QtWebEngineWidgets import QWebEngineView
from bs4 import BeautifulSoup

# ---- App paths ----
from init_db import init_db_if_needed
init_db_if_needed()
DB_PATH = Path("storage") / "search_time_machine.db"
APP_DIR = Path(__file__).resolve().parent
DEFAULT_OPML_PATH = str((APP_DIR / "archive_export.opml").resolve())
K_WEAVE = 3

# ---- aopmlengine must exist alongside this file ----
import aopmlengine

# ---------------------------------------------------------------------------
# Embedded "opml_extras_v3" shim (pretty, collapsible OPML tree for Qt)
# ---------------------------------------------------------------------------
# Safe text helpers
_XML_BAD = dict.fromkeys(range(0x00, 0x20), None)
for k in (0x09, 0x0A, 0x0D):  # keep TAB/LF/CR
    _XML_BAD.pop(k, None)

def _safe_text(s: str, max_len: int = 240) -> str:
    if not s:
        return ""
    s = str(s).translate(_XML_BAD)
    s = " ".join(s.split())
    if len(s) > max_len:
        s = s[: max_len - 1] + "…"
    return s

def _load_opml_nodes(path: str):
    doc = ET.parse(path)
    body = doc.getroot().find("./body")
    if body is None:
        return []
    return list(body.findall("./outline"))

def _outline_to_item(xml_el, parent: QTreeWidgetItem | None, tree: QTreeWidget):
    text = _safe_text(xml_el.attrib.get("text", "(untitled)"), 4096)
    attrs = {k: _safe_text(v, 4096) for k, v in xml_el.attrib.items()}
    item = QTreeWidgetItem([text or "(untitled)"])
    item.setData(0, Qt.UserRole, attrs)
    if attrs.get("_local_id"):
        item.setForeground(0, Qt.darkCyan)
    if parent is None:
        tree.addTopLevelItem(item)
    else:
        parent.addChild(item)
    for child in xml_el.findall("./outline"):
        _outline_to_item(child, item, tree)

def populate_qtree_from_opml(tree: QTreeWidget, path: str, *, expand_depth: int = 1):
    tree.clear()
    try:
        roots = _load_opml_nodes(path)
    except Exception as e:
        tree.addTopLevelItem(QTreeWidgetItem([f"(failed to load OPML: {e})"]))
        return
    if not roots:
        tree.addTopLevelItem(QTreeWidgetItem(["(empty outline)"]))
        return
    for el in roots:
        _outline_to_item(el, None, tree)
    tree.expandToDepth(max(0, expand_depth))

def expand_all(tree: QTreeWidget): tree.expandAll()
def collapse_all(tree: QTreeWidget): tree.collapseAll()
# ---------------------------------------------------------------------------

def ensure_archive_table(db_path: Path):
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS archive_pages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            url TEXT,
            title TEXT,
            captured_at TEXT,
            snippet TEXT,
            html TEXT,
            clean_html TEXT
        );
        """
    )
    try:
        cur.execute("ALTER TABLE archive_pages ADD COLUMN clean_html TEXT;")
    except sqlite3.OperationalError:
        pass
    conn.commit()
    conn.close()

def html_to_snippet(html: str, max_len: int = 500) -> str:
    text = re.sub(r"<script.*?</script>", " ", html, flags=re.IGNORECASE | re.DOTALL)
    text = re.sub(r"<style.*?</style>", " ", text, flags=re.IGNORECASE | re.DOTALL)
    text = re.sub(r"<[^>]+>", " ", text)
    text = re.sub(r"\s+", " ", text).strip()
    return text[:max_len]

def sanitize_html_for_reader(raw_html: str) -> str:
    cleaned = re.sub(r"<script.*?</script>", "", raw_html, flags=re.IGNORECASE | re.DOTALL)
    cleaned = re.sub(r"<iframe.*?</iframe>", "", cleaned, flags=re.IGNORECASE | re.DOTALL)
    cleaned = re.sub(r"<link[^>]+rel=[\"']?(preload|dns-prefetch|preconnect|modulepreload)[\"']?[^>]*>", "", cleaned, flags=re.IGNORECASE)
    cleaned = re.sub(r"\son\w+\s*=\s*['\"].*?['\"]", "", cleaned, flags=re.IGNORECASE | re.DOTALL)
    return cleaned

def save_archive_page(db_path: Path, url: str, title: str, html: str):
    ensure_archive_table(db_path)
    captured_at = datetime.utcnow().isoformat(timespec="seconds") + "Z"
    snippet = html_to_snippet(html)
    clean_html = sanitize_html_for_reader(html)
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute(
        """
        INSERT INTO archive_pages (url, title, captured_at, snippet, html, clean_html)
        VALUES (?, ?, ?, ?, ?, ?);
        """,
        (url, title, captured_at, snippet, html, clean_html),
    )
    conn.commit()
    conn.close()

def _clean_for_capsule(s: str) -> str:
    s = s.replace("```", "ʼʼʼ")
    s = re.sub(r"\s+\n", "\n", s)
    return s.strip()

def build_context_capsule_for_snapshot(*, title: str, url: str, captured_at: str, snippet: str, body: str, hard_cap_chars: int = 6500) -> str:
    title = _clean_for_capsule(title); url = _clean_for_capsule(url)
    snippet = _clean_for_capsule(snippet); body = _clean_for_capsule(body)
    max_body = max(0, min(5200, hard_cap_chars - 1000))
    body_slice = body[:max_body]
    header = (f"### Context Capsule — ai_navigator\n"
              f"Title: {title}\nURL: {url}\nCaptured: {captured_at}\n---\n")
    snippet_block = f"**Snippet**\n{snippet}\n\n" if snippet else ""
    html_block = f"**Reader-Mode HTML (excerpt)**\n```html\n{body_slice}\n```\n"
    footer = ("\nContinue from this capsule. Summarize key points from the page, "
              "then propose the next 1–2 actions or questions. If anything is unclear, "
              "ask for the single most relevant detail rather than restarting.")
    capsule = header + snippet_block + html_block + footer
    if len(capsule) > hard_cap_chars:
        capsule = capsule[: hard_cap_chars - 25] + "\n…[truncated]…"
    return capsule

def build_memory_weave_packet(conn: sqlite3.Connection, current_page_id: int, k: int = 3, hard_cap_chars: int = 7000) -> str:
    cur = conn.cursor()
    cur.execute("SELECT url, title, captured_at, snippet FROM archive_pages WHERE id = ?;", (current_page_id,))
    row = cur.fetchone()
    if not row:
        return build_global_weave_packet(conn, k=k, hard_cap_chars=hard_cap_chars)
    sel_url, _, _, _ = row
    domain = urlparse(sel_url or "").netloc.lower()
    items = []
    if domain:
        cur.execute(
            """SELECT id, title, url, captured_at, snippet
               FROM archive_pages WHERE url LIKE ? ORDER BY captured_at DESC LIMIT ?;""",
            (f"%://{domain}%", k),
        )
        items = cur.fetchall()
    if len(items) < k:
        have_ids = {r[0] for r in items}
        need = k - len(items)
        cur.execute("""SELECT id, title, url, captured_at, snippet
                       FROM archive_pages ORDER BY captured_at DESC LIMIT ?;""",
                    (k * 3,))
        for r in cur.fetchall():
            if r[0] not in have_ids:
                items.append(r)
                if len(items) >= k:
                    break
    header = "### Context Capsule — ai_navigator\n"
    if domain: header += f"Thread scope: {domain}\n"
    header += f"Captured: {datetime.utcnow().isoformat(timespec='seconds')}Z\n---\n"
    lines = []
    for _id, title, url, ts, snip in items:
        title = _clean_for_capsule(title or "(untitled)")
        url = _clean_for_capsule(url or ""); ts = _clean_for_capsule(ts or "")
        snip = _clean_for_capsule((snip or "")[:240])
        lines.append(f"— {ts} · {title} · {url}")
        if snip: lines.append(f"   {snip}")
    footer = ("\n(End of memory weave)\n\n"
              "Continue from these three context points. Summarize the through-line you infer, "
              "then propose the next one or two actions.")
    capsule = header + "\n".join(lines) + "\n" + footer
    if len(capsule) > hard_cap_chars:
        capsule = capsule[: hard_cap_chars - 25] + "\n…[truncated]…"
    return capsule

def build_global_weave_packet(conn: sqlite3.Connection, k: int = 3, hard_cap_chars: int = 7000) -> str:
    cur = conn.cursor()
    cur.execute("""SELECT id, title, url, captured_at, snippet
                   FROM archive_pages ORDER BY captured_at DESC LIMIT ?;""", (k,))
    rows = cur.fetchall()
    header = "### Context Capsule — ai_navigator\nThread scope: global\n"
    header += f"Captured: {datetime.utcnow().isoformat(timespec='seconds')}Z\n---\n"
    lines = []
    for _id, title, url, ts, snip in rows:
        title = _clean_for_capsule(title or "(untitled)")
        url = _clean_for_capsule(url or ""); ts = _clean_for_capsule(ts or "")
        snip = _clean_for_capsule((snip or "")[:240])
        lines.append(f"— {ts} · {title} · {url}")
        if snip: lines.append(f"   {snip}")
    footer = ("\n(End of memory weave)\n\n"
              "Continue from these three context points. Summarize the through-line you infer, "
              "then propose the next one or two actions.")
    capsule = header + "\n".join(lines) + "\n" + footer
    if len(capsule) > hard_cap_chars:
        capsule = capsule[: hard_cap_chars - 25] + "\n…[truncated]…"
    return capsule

class ThrobberWidget(QWidget):
    def __init__(self, parent=None, size=24):
        super().__init__(parent); self.setFixedSize(QSize(size, size))
        self.angle = 0; self.timer = QTimer(self); self.timer.setInterval(50)
        self.timer.timeout.connect(self._tick); self.base_pixmap = self._make_base_pixmap(size)
    def _make_base_pixmap(self, size: int) -> QPixmap:
        pm = QPixmap(size, size); pm.fill(Qt.transparent); p = QPainter(pm)
        p.setRenderHint(QPainter.Antialiasing, True); p.setBrush(QBrush(QColor(0,60,90)))
        p.setPen(QPen(QColor(200,230,255), 1)); p.drawEllipse(QRect(1,1,size-2,size-2))
        p.setPen(Qt.white); p.setBrush(Qt.white); w,h = size,size
        path = QPainterPath(); path.moveTo(0.5*w,0.18*h); path.lineTo(0.18*w,0.85*h); path.lineTo(0.82*w,0.85*h); path.closeSubpath(); p.drawPath(path)
        p.fillRect(QRect(int(0.33*w), int(0.55*h), int(0.34*w), int(0.12*h)), Qt.white); p.end(); return pm
    def _tick(self): self.angle = (self.angle + 15) % 360; self.update()
    def start(self): 
        if not self.timer.isActive(): self.timer.start()
    def stop(self):
        if self.timer.isActive(): self.timer.stop()
    def paintEvent(self, e):
        p = QPainter(self); p.setRenderHint(QPainter.SmoothPixmapTransform, True)
        cx,cy = self.width()/2.0, self.height()/2.0
        t = QTransform(); t.translate(cx,cy); t.rotate(self.angle); t.translate(-cx,-cy)
        rotated = self.base_pixmap.transformed(t, Qt.SmoothTransformation)
        x = (self.width()-rotated.width())/2.0; y = (self.height()-rotated.height())/2.0
        p.drawPixmap(int(x), int(y), rotated); p.end()

class BrowserPane(QWidget):
    def __init__(self, on_page_loaded=None, on_archive_request=None):
        super().__init__(); self.on_page_loaded = on_page_loaded; self.on_archive_request = on_archive_request
        self.view = QWebEngineView()
        self.url_bar = QLineEdit(); self.go_button = QPushButton("Go")
        self.back_button = QPushButton("←"); self.fwd_button = QPushButton("→")
        self.reload_button = QPushButton("Reload"); self.home_button = QPushButton("Home")
        self.archive_button = QPushButton("Archive"); self.opml_button = QPushButton("Outline (OPML export)")
        self.throbber = ThrobberWidget(size=24)
        self.status_label = QLabel("Ready.")
        self.status_label.setStyleSheet("font-size:11px;color:#d0e8ff;background-color:#003c5a;padding:2px;")
        self.status_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        toolbar_row = QHBoxLayout(); toolbar_bg = QWidget()
        toolbar_bg.setStyleSheet("background-color:#003c5a;color:white;border-bottom:1px solid #99ccee;")
        toolbar_bg.setLayout(toolbar_row)
        btn_style = ("QPushButton { background-color:#195b7e; color:#fff; border:1px solid #99ccee; padding:3px 6px; font-weight:bold; }"
                     "QPushButton:pressed { background-color:#0f3b52; }")
        for b in (self.back_button,self.fwd_button,self.reload_button,self.home_button,self.go_button,self.archive_button,self.opml_button):
            b.setStyleSheet(btn_style)
        self.url_bar.setStyleSheet("QLineEdit { background-color:#dfefff; color:#000; border:1px solid #99ccee; padding:2px 4px; }")
        toolbar_row.addWidget(QLabel("AI Navigator", parent=toolbar_bg))
        toolbar_row.addWidget(self.back_button); toolbar_row.addWidget(self.fwd_button)
        toolbar_row.addWidget(self.reload_button); toolbar_row.addWidget(self.home_button)
        toolbar_row.addWidget(QLabel("URL:", parent=toolbar_bg)); toolbar_row.addWidget(self.url_bar, stretch=1)
        toolbar_row.addWidget(self.go_button); toolbar_row.addWidget(self.archive_button)
        toolbar_row.addWidget(self.opml_button); toolbar_row.addWidget(self.throbber)
        status_row = QHBoxLayout(); status_bg = QWidget()
        status_bg.setStyleSheet("background-color:#003c5a;border-top:1px solid #99ccee;")
        status_bg.setLayout(status_row); status_row.addWidget(self.status_label)
        lay = QVBoxLayout(); lay.setContentsMargins(0,0,0,0)
        lay.addWidget(toolbar_bg); lay.addWidget(self.view, stretch=1); lay.addWidget(status_bg); self.setLayout(lay)
        self.home_url = "https://www.google.com/"
        self.go_button.clicked.connect(self.load_url); self.url_bar.returnPressed.connect(self.load_url)
        self.back_button.clicked.connect(self.view.back); self.fwd_button.clicked.connect(self.view.forward)
        self.reload_button.clicked.connect(self.view.reload); self.home_button.clicked.connect(self.load_home)
        self.archive_button.clicked.connect(self._archive_current_page); self.opml_button.clicked.connect(self._export_outline_opml)
        self.view.loadStarted.connect(self._on_load_started)
        self.view.loadProgress.connect(self._on_load_progress)
        self.view.loadFinished.connect(self._on_load_finished)
        self.url_bar.setText(self.home_url); self.load_url()
    def load_home(self): self.url_bar.setText(self.home_url); self.load_url()
    def load_url(self):
        url = self.url_bar.text().strip()
        if not url.startswith("http"): url = "https://" + url
        self.view.setUrl(QUrl(url))
    def load_html_snapshot(self, html: str, base_url: str):
        self.view.setHtml(html, baseUrl=QUrl(base_url)); self.status_label.setText("Loaded Reader-Mode snapshot (offline).")
        self.url_bar.setText(base_url)
    def _on_load_started(self): self.throbber.start(); self.status_label.setText("Contacting host...")
    def _on_load_progress(self, pct: int): self.status_label.setText(f"Transferring data... {pct}%")
    def _on_load_finished(self, ok: bool):
        self.throbber.stop()
        if ok:
            current_url = self.view.url().toString(); self.url_bar.setText(current_url)
            self.status_label.setText("Done."); 
            if self.on_page_loaded: self.on_page_loaded(current_url)
        else:
            self.status_label.setText("Load failed."); QMessageBox.warning(self, "Load error", "Page failed to load.")
    def _archive_current_page(self):
        current_url = self.view.url().toString(); current_title = self.view.title() or current_url
        def got_html(html_str):
            if self.on_archive_request: self.on_archive_request(current_url, current_title, html_str)
        self.view.page().toHtml(got_html)
    def _export_outline_opml(self):
        def _on_html(html: str):
            try:
                title = self.view.title() or ""
                soup = BeautifulSoup(html or "", "lxml")
                doc_title = title or (soup.title.string if soup.title else "Untitled")
                nodes=[]
                for tag in soup.find_all(["h1","h2","h3","h4","h5","h6"]):
                    level = int(tag.name[1]); text = tag.get_text(" ", strip=True)
                    if text: nodes.append((level,text))
                out = ['<?xml version="1.0"?>','<opml version="2.0"><head>',f"<title>{doc_title}</title>","</head><body>"]
                stack=[0]
                for level,text in nodes:
                    while stack and level <= stack[-1]:
                        out.append("</outline>"); stack.pop()
                    out.append(f'<outline text="{text}">'); stack.append(level)
                while len(stack)>1: out.append("</outline>"); stack.pop()
                out.append("</body></opml>")
                opml = "\n".join(out)
                outdir = Path.cwd() / "archives" / "opml"; outdir.mkdir(parents=True, exist_ok=True)
                ts = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ"); name = re.sub(r'[^A-Za-z0-9\-]+','-', (title or "page")).strip("-") or "page"
                outpath = outdir / f"{name}-{ts}.opml"
                outpath.write_text(opml, encoding="utf-8")
                self.status_label.setText(f"OPML saved → {outpath}"); QMessageBox.information(self, "OPML export", f"Saved:\n{outpath}")
            except Exception as e:
                QMessageBox.critical(self, "OPML export failed", str(e))
        self.view.page().toHtml(_on_html)

class ResultsPane(QWidget):
    recoveredPage = Signal(str, str)  # html, url
    def __init__(self, db_path: Path):
        super().__init__(); self.db_path = db_path; self.conn = None
        self.archive_list = QListWidget(); self.details_list = QListWidget()
        self.recover_button = QPushButton("Recover")
        self.recover_chat_button = QPushButton("Recover to ChatGPT")
        self.recover_weave_button = QPushButton("Recover Memory Weave")
        header_label = QLabel("Archived Pages"); header_label.setStyleSheet("font-weight:bold;background-color:#003c5a;color:#fff;padding:4px;")
        details_label = QLabel("Details"); details_label.setStyleSheet("font-weight:bold;background-color:#003c5a;color:#fff;padding:4px;")
        btn_style = ("QPushButton { background-color:#195b7e; color:#fff; border:1px solid #99ccee; padding:3px 6px; font-weight:bold; }"
                     "QPushButton:pressed { background-color:#0f3b52; }")
        for b in (self.recover_button,self.recover_chat_button,self.recover_weave_button): b.setStyleSheet(btn_style)
        lay = QVBoxLayout(); lay.setContentsMargins(0,0,0,0)
        lay.addWidget(header_label); lay.addWidget(self.archive_list, stretch=1)
        details_header = QHBoxLayout(); details_header.addWidget(details_label); details_header.addStretch(1)
        details_header.addWidget(self.recover_weave_button); details_header.addWidget(self.recover_chat_button); details_header.addWidget(self.recover_button)
        lay.addLayout(details_header); lay.addWidget(self.details_list, stretch=2); self.setLayout(lay)
        self.archive_list.currentItemChanged.connect(self._populate_details_for_archive)
        self.recover_button.clicked.connect(self._recover_selected)
        self.recover_chat_button.clicked.connect(self._recover_to_chatgpt_selected)
        self.recover_weave_button.clicked.connect(self._recover_memory_weave_selected)
        self._ensure_connection(); self._populate_archive_list()
    def _ensure_connection(self):
        if self.conn is None:
            ensure_archive_table(self.db_path); self.conn = sqlite3.connect(self.db_path)
    def _populate_archive_list(self):
        self.archive_list.clear()
        if self.conn is None: return
        cur = self.conn.cursor()
        cur.execute("""SELECT id, title, captured_at FROM archive_pages ORDER BY captured_at DESC LIMIT 200;""")
        for page_id, title, captured_at in cur.fetchall():
            item = QListWidgetItem(f"{title}    ({captured_at})"); item.setData(Qt.UserRole, page_id); self.archive_list.addItem(item)
    def _populate_details_for_archive(self, current: QListWidgetItem, previous: QListWidgetItem):
        self.details_list.clear()
        if self.conn is None or current is None: return
        page_id = current.data(Qt.UserRole); cur = self.conn.cursor()
        cur.execute("SELECT url, snippet FROM archive_pages WHERE id = ?;", (page_id,))
        row = cur.fetchone()
        if not row:
            return
        url, snip = row; self.details_list.addItem(QListWidgetItem(f"{url}\n\n{snip}"))
    def _recover_selected(self):
        if self.conn is None:
            QMessageBox.warning(self, "No DB", "Database not available."); return
        item = self.archive_list.currentItem()
        if item is None:
            QMessageBox.information(self, "No selection", "Select an archived page first."); return
        page_id = item.data(Qt.UserRole); cur = self.conn.cursor()
        cur.execute("""SELECT url, COALESCE(clean_html, html) FROM archive_pages WHERE id = ?;""", (page_id,))
        row = cur.fetchone()
        if not row:
            QMessageBox.warning(self, "Not found", "That archived page no longer exists."); return
        url, html_for_reader = row; self.recoveredPage.emit(html_for_reader, url)
    def _recover_to_chatgpt_selected(self):
        try:
            if self.conn is None:
                QMessageBox.warning(self, "No DB", "Database not available."); return
            item = self.archive_list.currentItem()
            if item is None:
                QMessageBox.information(self, "No selection", "Select an archived page first."); return
            page_id = item.data(Qt.UserRole); cur = self.conn.cursor()
            cur.execute("""SELECT title, url, captured_at, snippet, COALESCE(clean_html, html) FROM archive_pages WHERE id = ?;""", (page_id,))
            row = cur.fetchone()
            if not row:
                QMessageBox.warning(self, "Not found", "That archived page no longer exists."); return
            title, url, captured_at, snippet, body = row
            capsule = build_context_capsule_for_snapshot(title=title or url or "(untitled)", url=url or "about:blank",
                                                         captured_at=captured_at or "", snippet=snippet or "", body=body or "", hard_cap_chars=6500)
            copied = copy_to_clipboard(capsule); target = "https://chatgpt.com/"
            opened = QDesktopServices.openUrl(QUrl(target)) or webbrowser.open_new_tab(target)
            if not opened:
                try: subprocess.Popen(["xdg-open", target], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                except Exception: pass
            if copied: QMessageBox.information(self, "Capsule ready", "Context Capsule copied to clipboard.\nSwitch to ChatGPT and paste.")
            else: QMessageBox.warning(self, "Clipboard problem", "Couldn't access the system clipboard.")
        except Exception as e:
            QMessageBox.critical(self, "Recover to ChatGPT failed", str(e))
    def _recover_memory_weave_selected(self):
        try:
            if self.conn is None:
                QMessageBox.warning(self, "No DB", "Database not available."); return
            item = self.archive_list.currentItem()
            if item is None:
                QMessageBox.information(self, "No selection", "Select an archived page first."); return
            page_id = item.data(Qt.UserRole)
            capsule = build_memory_weave_packet(self.conn, page_id, k=K_WEAVE, hard_cap_chars=7000)
            copied = copy_to_clipboard(capsule); target = "https://chatgpt.com/"
            opened = QDesktopServices.openUrl(QUrl(target)) or webbrowser.open_new_tab(target)
            if not opened:
                try: subprocess.Popen(["xdg-open", target], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                except Exception: pass
            if copied: QMessageBox.information(self, "Weave ready", "Memory Weave copied to clipboard (k=3).")
            else: QMessageBox.warning(self, "Clipboard problem", "Couldn't access the system clipboard.")
        except Exception as e:
            QMessageBox.critical(self, "Recover Memory Weave failed", str(e))
    def refresh_all(self):
        if self.conn is None: self._ensure_connection()
        self._populate_archive_list()

def _slug(s: str) -> str:
    s = re.sub(r"\s+", "-", (s or "").strip()); s = re.sub(r"[^A-Za-z0-9\-_]+", "", s)
    return s or "page"

class OutlinePane(QWidget):
    def __init__(self, db_path: Path, on_open_local=None, opml_path: str = DEFAULT_OPML_PATH):
        super().__init__(); self.db_path = db_path; self.on_open_local = on_open_local
        self.opml_path = opml_path
        self.tree = QTreeWidget(); self.tree.setHeaderHidden(True)
        self.reload_button = QPushButton("Reload"); self.generate_button = QPushButton("Generate")
        self.reveal_button = QPushButton("Reveal"); self.expand_button = QPushButton("Expand"); self.collapse_button = QPushButton("Collapse")
        for b in (self.reload_button,self.generate_button,self.reveal_button,self.expand_button,self.collapse_button):
            b.setStyleSheet("QPushButton { background-color:#195b7e; color:#fff; border:1px solid #99ccee; padding:3px 6px; font-weight:bold; }"
                            "QPushButton:pressed { background-color:#0f3b52; }")
        header_label = QLabel("Outline (OPML export)")
        header_label.setStyleSheet("font-weight:bold;background-color:#003c5a;color:#fff;padding:4px;")
        header_row = QHBoxLayout(); header_row.addWidget(header_label); header_row.addStretch(1)
        header_row.addWidget(self.generate_button); header_row.addWidget(self.reload_button)
        header_row.addWidget(self.expand_button); header_row.addWidget(self.collapse_button)
        header_row.addWidget(self.reveal_button)
        self.opml_path_label = QLabel(self.opml_path); self.opml_path_label.setStyleSheet("font-size:11px;color:#66c;")
        path_row = QHBoxLayout(); path_row.addWidget(QLabel("File:")); path_row.addWidget(self.opml_path_label); path_row.addStretch(1)
        lay = QVBoxLayout(); lay.setContentsMargins(0,0,0,0)
        lay.addLayout(header_row); lay.addLayout(path_row); lay.addWidget(self.tree, stretch=1); self.setLayout(lay)
        self._populate_tree_from_opml()
        self.tree.itemActivated.connect(self._handle_activate)
        self.reload_button.clicked.connect(self.reload_outline)
        self.generate_button.clicked.connect(self.generate_outline_from_db)
        self.reveal_button.clicked.connect(lambda: QDesktopServices.openUrl(QUrl.fromLocalFile(str(Path(self.opml_path).parent))))
        self.expand_button.clicked.connect(lambda: expand_all(self.tree))
        self.collapse_button.clicked.connect(lambda: collapse_all(self.tree))
    def generate_outline_from_db(self):
        try:
            aopmlengine.export_archive_to_opml(db_path=str(self.db_path), out_path=str(self.opml_path), owner_name="Glen")
            self.opml_path_label.setText(self.opml_path)
            self._populate_tree_from_opml()
            QMessageBox.information(self, "OPML generated", f"Saved:\n{self.opml_path}")
        except Exception as e:
            QMessageBox.critical(self, "Generate failed", str(e))
    def _populate_tree_from_opml(self):
        try:
            populate_qtree_from_opml(self.tree, self.opml_path, expand_depth=1)
        except Exception as e:
            self.tree.clear()
            self.tree.addTopLevelItem(QTreeWidgetItem(["(no outline loaded)"]))
            QMessageBox.warning(self, "OPML load failed", f"No outline loaded from:\n{self.opml_path}\n\n{e}")
    def reload_outline(self): self._populate_tree_from_opml()
    def _handle_activate(self, item, column):
        attrs = item.data(0, Qt.UserRole) or {}
        local_id = attrs.get("_local_id")
        if local_id and self.on_open_local:
            try: self.on_open_local(int(local_id))
            except ValueError: pass

class AssistantPane(QWidget):
    def __init__(self):
        super().__init__()
        self.input_line = QLineEdit(); self.ask_button = QPushButton("Ask")
        self.output_box = QTextEdit(); self.output_box.setReadOnly(True)
        guide_label = QLabel("Navigator Guide"); guide_label.setStyleSheet("font-weight:bold;background-color:#003c5a;color:#fff;padding:4px;")
        top_row = QHBoxLayout(); top_row.addWidget(QLabel("Ask:")); top_row.addWidget(self.input_line); top_row.addWidget(self.ask_button)
        lay = QVBoxLayout(); lay.setContentsMargins(0,0,0,0)
        lay.addWidget(guide_label); lay.addLayout(top_row); lay.addWidget(QLabel("Assistant Response:")); lay.addWidget(self.output_box, stretch=1)
        self.setLayout(lay)
        self.ask_button.clicked.connect(self.handle_ask); self.input_line.returnPressed.connect(self.handle_ask)
    def handle_ask(self):
        q = self.input_line.text().strip()
        if not q: return
        self.output_box.setPlainText("Outline is live. Use Generate → Reload. Expand/Collapse help scan long trees quickly.")

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("AI Navigator"); self.resize(1600, 900)
        self.results_pane = ResultsPane(DB_PATH); self.assistant_pane = AssistantPane()
        self.browser_pane = BrowserPane(on_page_loaded=self._handle_page_loaded, on_archive_request=self._handle_archive_request)
        self.outline_pane = OutlinePane(DB_PATH, on_open_local=self._open_local_snapshot_by_id, opml_path=DEFAULT_OPML_PATH)
        self.results_pane.recoveredPage.connect(self._handle_recovered_page)
        mid = QSplitter(Qt.Horizontal); mid.addWidget(self.results_pane); mid.addWidget(self.outline_pane); mid.addWidget(self.assistant_pane); mid.setSizes([300,300,400])
        outer = QSplitter(Qt.Horizontal); outer.addWidget(self.browser_pane); outer.addWidget(mid); outer.setSizes([900,700])
        central = QWidget(); lay = QVBoxLayout(central); lay.setContentsMargins(0,0,0,0); lay.addWidget(outer); self.setCentralWidget(central)
        self.weave_store = WeaveStore()
        self.weave_dock = QDockWidget("Memory Weave", self); self.weave_pane = MemoryWeavePane(self.weave_store, self.weave_dock)
        self.weave_dock.setWidget(self.weave_pane); self.addDockWidget(Qt.RightDockWidgetArea, self.weave_dock)
        mb: QMenuBar = self.menuBar(); m = mb.addMenu("Weave")
        act_cap = m.addAction("Capture Checkpoint"); act_cap.triggered.connect(lambda: self._capture_current_page_checkpoint())
        act_toggle = m.addAction("Toggle Weave Pane"); act_toggle.triggered.connect(lambda: self.weave_dock.setVisible(!self.weave_dock.isVisible()))
    # ----- Memory Weave glue -----
    def _current_page_meta(self):
        try: title = self.browser_pane.view.title() or "(untitled)"
        except Exception: title = "(untitled)"
        try: url = self.browser_pane.view.url().toString()
        except Exception: url = ""
        return title, url
    def _capture_current_page_checkpoint(self, summary: str | None = None, tags: list[str] | None = None):
        title, url = self._current_page_meta()
        if not url: return
        summary = (summary or "").strip(); tags = tags or []
        data = {"address_bar_value": url, "window_size": (self.width(), self.height()), "note": "Captured via Memory Weave pane"}
        self.weave_store.capture(title=title, url=url, summary=summary, tags=tags, data=data); self.weave_pane._load()
    def _on_reweave_requested(self, weave_id: int, url: str):
        if url: self.browser_pane.url_bar.setText(url); self.browser_pane.load_url()
    # ----- App plumbing -----
    def _handle_page_loaded(self, url_str: str): pass
    def _handle_archive_request(self, url: str, title: str, html: str):
        save_archive_page(DB_PATH, url, title, html); self.results_pane.refresh_all()
    def _handle_recovered_page(self, html: str, url: str):
        self.browser_pane.load_html_snapshot(html, url)
    def _open_local_snapshot_by_id(self, row_id: int):
        conn = sqlite3.connect(DB_PATH); cur = conn.cursor()
        cur.execute("""SELECT url, COALESCE(clean_html, html) FROM archive_pages WHERE id = ?;""", (row_id,))
        row = cur.fetchone(); conn.close()
        if not row: QMessageBox.warning(self, "Not found", f"No snapshot with id {row_id}"); return
        url, html_for_reader = row; self.browser_pane.load_html_snapshot(html_for_reader, url or "about:blank")

# ---- Memory Weave deps ----
from memory_weave_pane import MemoryWeavePane
from weave_store import WeaveStore

# ---- Clipboard fallback helper ----
def copy_to_clipboard(text: str) -> bool:
    ok = False
    try:
        cb = QGuiApplication.clipboard()
        if cb is not None:
            cb.setText(text or "")
            try: cb.setText(text or "", mode=QClipboard.Mode.Selection)
            except Exception: pass
            ok = True
    except Exception: ok = False
    if ok: return True
    for cmd in (["xclip","-selection","clipboard"], ["xsel","--clipboard","--input"]):
        try:
            p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            p.communicate(input=(text or "").encode("utf-8"), timeout=1.5)
            return True
        except Exception: continue
    return False

def main():
    os.environ.setdefault("QTWEBENGINE_CHROMIUM_FLAGS", "--no-sandbox")
    app = QApplication(sys.argv); w = MainWindow(); w.show(); sys.exit(app.exec())

if __name__ == "__main__":
    main()

